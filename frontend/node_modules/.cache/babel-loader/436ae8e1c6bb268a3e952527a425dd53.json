{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/nikitajethani/Desktop/cs 4530/covey.town-master/frontend/src/components/VideoCall/VideoFrontend/state/index.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { createContext, useContext, useReducer, useState } from 'react';\nimport { settingsReducer, initialSettings } from './settings/settingsReducer';\nexport const StateContext = /*#__PURE__*/createContext(null);\n/*\n  The 'react-hooks/rules-of-hooks' linting rules prevent React Hooks fron being called\n  inside of if() statements. This is because hooks must always be called in the same order\n  every time a component is rendered. The 'react-hooks/rules-of-hooks' rule is disabled below\n  because the \"if (process.env.REACT_APP_SET_AUTH === 'firebase')\" statements are evaluated\n  at build time (not runtime). If the statement evaluates to false, then the code is not\n  included in the bundle that is produced (due to tree-shaking). Thus, in this instance, it\n  is ok to call hooks inside if() statements.\n*/\n\nexport default function AppStateProvider(props) {\n  _s();\n\n  var _props$toggleWidth;\n\n  const [error, setError] = useState(null);\n  const [isFetching, setIsFetching] = useState(false);\n  const [activeSinkId, setActiveSinkId] = useState('default');\n  const [settings, dispatchSetting] = useReducer(settingsReducer, initialSettings);\n  const contextValue = {\n    error,\n    setError,\n    isFetching,\n    activeSinkId,\n    setActiveSinkId,\n    settings,\n    dispatchSetting,\n    toggleWidth: (_props$toggleWidth = props.toggleWidth) !== null && _props$toggleWidth !== void 0 ? _props$toggleWidth : () => {},\n    preferredMode: props.preferredMode,\n    highlightedProfiles: props.highlightedProfiles\n  };\n\n  const getToken = room => {\n    setIsFetching(true);\n    return contextValue.getToken(room).then(res => {\n      setIsFetching(false);\n      return res;\n    }).catch(err => {\n      setError(err);\n      setIsFetching(false);\n      return Promise.reject(err);\n    });\n  };\n\n  return /*#__PURE__*/_jsxDEV(StateContext.Provider, {\n    value: { ...contextValue,\n      getToken\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 85,\n    columnNumber: 10\n  }, this);\n}\n\n_s(AppStateProvider, \"1ZsqN7lB+82LAqyc+jd+Dcrom1Q=\");\n\n_c = AppStateProvider;\nexport function useAppState() {\n  _s2();\n\n  const context = useContext(StateContext);\n\n  if (!context) {\n    throw new Error('useAppState must be used within the AppStateProvider');\n  }\n\n  return context;\n}\n\n_s2(useAppState, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"AppStateProvider\");","map":{"version":3,"sources":["/Users/nikitajethani/Desktop/cs 4530/covey.town-master/frontend/src/components/VideoCall/VideoFrontend/state/index.tsx"],"names":["React","createContext","useContext","useReducer","useState","settingsReducer","initialSettings","StateContext","AppStateProvider","props","error","setError","isFetching","setIsFetching","activeSinkId","setActiveSinkId","settings","dispatchSetting","contextValue","toggleWidth","preferredMode","highlightedProfiles","getToken","room","then","res","catch","err","Promise","reject","children","useAppState","context","Error"],"mappings":";;;;;;AAAA,OAAOA,KAAP,IACEC,aADF,EACiBC,UADjB,EAC6BC,UAD7B,EACyCC,QADzC,QAEO,OAFP;AAMA,SACEC,eADF,EACmBC,eADnB,QAEO,4BAFP;AA2BA,OAAO,MAAMC,YAAY,gBAAGN,aAAa,CAAmB,IAAnB,CAAlC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASO,gBAAT,CACbC,KADa,EAMb;AAAA;;AAAA;;AACA,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBP,QAAQ,CAAqB,IAArB,CAAlC;AACA,QAAM,CAACQ,UAAD,EAAaC,aAAb,IAA8BT,QAAQ,CAAC,KAAD,CAA5C;AACA,QAAM,CAACU,YAAD,EAAeC,eAAf,IAAkCX,QAAQ,CAAC,SAAD,CAAhD;AACA,QAAM,CAACY,QAAD,EAAWC,eAAX,IAA8Bd,UAAU,CAACE,eAAD,EAAkBC,eAAlB,CAA9C;AAEA,QAAMY,YAAY,GAAG;AACnBR,IAAAA,KADmB;AAEnBC,IAAAA,QAFmB;AAGnBC,IAAAA,UAHmB;AAInBE,IAAAA,YAJmB;AAKnBC,IAAAA,eALmB;AAMnBC,IAAAA,QANmB;AAOnBC,IAAAA,eAPmB;AAQnBE,IAAAA,WAAW,wBAAEV,KAAK,CAACU,WAAR,mEAAwB,MAAM,CAAE,CARxB;AASnBC,IAAAA,aAAa,EAAEX,KAAK,CAACW,aATF;AAUnBC,IAAAA,mBAAmB,EAAEZ,KAAK,CAACY;AAVR,GAArB;;AAaA,QAAMC,QAAsC,GAAIC,IAAD,IAAU;AACvDV,IAAAA,aAAa,CAAC,IAAD,CAAb;AACA,WAAOK,YAAY,CAChBI,QADI,CACKC,IADL,EAEJC,IAFI,CAEEC,GAAD,IAAS;AACbZ,MAAAA,aAAa,CAAC,KAAD,CAAb;AACA,aAAOY,GAAP;AACD,KALI,EAMJC,KANI,CAMGC,GAAD,IAAS;AACdhB,MAAAA,QAAQ,CAACgB,GAAD,CAAR;AACAd,MAAAA,aAAa,CAAC,KAAD,CAAb;AACA,aAAOe,OAAO,CAACC,MAAR,CAAeF,GAAf,CAAP;AACD,KAVI,CAAP;AAWD,GAbD;;AAeA,sBAAO,QAAC,YAAD,CAAc,QAAd;AAAuB,IAAA,KAAK,EAAE,EAAE,GAAGT,YAAL;AAAmBI,MAAAA;AAAnB,KAA9B;AAAA,cAA8Db,KAAK,CAACqB;AAApE;AAAA;AAAA;AAAA;AAAA,UAAP;AACD;;GAzCuBtB,gB;;KAAAA,gB;AA2CxB,OAAO,SAASuB,WAAT,GAAuB;AAAA;;AAC5B,QAAMC,OAAO,GAAG9B,UAAU,CAACK,YAAD,CAA1B;;AACA,MAAI,CAACyB,OAAL,EAAc;AACZ,UAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACD;;AACD,SAAOD,OAAP;AACD;;IANeD,W","sourcesContent":["import React, {\n  createContext, useContext, useReducer, useState,\n} from 'react';\nimport { TwilioError } from 'twilio-video';\nimport assert from 'assert';\nimport { RoomType } from '../types';\nimport {\n  settingsReducer, initialSettings, Settings, SettingsAction,\n} from './settings/settingsReducer';\nimport { VideoRoom } from '../../../../CoveyTypes';\n\nexport interface StateContextType {\n  error: TwilioError | null;\n  setError(error: TwilioError | null): void;\n  getToken(\n    room: VideoRoom\n  ): Promise<{\n    token: string | null;\n    expiry: Date | null;\n    twilioRoomId: string | null;\n  }>;\n  isAuthReady?: boolean;\n  isFetching: boolean;\n  activeSinkId: string;\n  setActiveSinkId(sinkId: string): void;\n  settings: Settings;\n  dispatchSetting: React.Dispatch<SettingsAction>;\n  roomType?: RoomType;\n  toggleWidth(): void;\n  preferredMode: 'sidebar' | 'fullwidth';\n  highlightedProfiles: string[];\n}\n\nexport const StateContext = createContext<StateContextType>(null!);\n\n/*\n  The 'react-hooks/rules-of-hooks' linting rules prevent React Hooks fron being called\n  inside of if() statements. This is because hooks must always be called in the same order\n  every time a component is rendered. The 'react-hooks/rules-of-hooks' rule is disabled below\n  because the \"if (process.env.REACT_APP_SET_AUTH === 'firebase')\" statements are evaluated\n  at build time (not runtime). If the statement evaluates to false, then the code is not\n  included in the bundle that is produced (due to tree-shaking). Thus, in this instance, it\n  is ok to call hooks inside if() statements.\n*/\nexport default function AppStateProvider(\n  props: React.PropsWithChildren<{\n    toggleWidth?: StateContextType['toggleWidth'];\n    preferredMode: StateContextType['preferredMode'];\n    highlightedProfiles: StateContextType['highlightedProfiles'];\n  }>,\n) {\n  const [error, setError] = useState<TwilioError | null>(null);\n  const [isFetching, setIsFetching] = useState(false);\n  const [activeSinkId, setActiveSinkId] = useState('default');\n  const [settings, dispatchSetting] = useReducer(settingsReducer, initialSettings);\n\n  const contextValue = {\n    error,\n    setError,\n    isFetching,\n    activeSinkId,\n    setActiveSinkId,\n    settings,\n    dispatchSetting,\n    toggleWidth: props.toggleWidth ?? (() => {}),\n    preferredMode: props.preferredMode,\n    highlightedProfiles: props.highlightedProfiles,\n  } as StateContextType;\n\n  const getToken: StateContextType['getToken'] = (room) => {\n    setIsFetching(true);\n    return contextValue\n      .getToken(room)\n      .then((res) => {\n        setIsFetching(false);\n        return res;\n      })\n      .catch((err) => {\n        setError(err);\n        setIsFetching(false);\n        return Promise.reject(err);\n      });\n  };\n\n  return <StateContext.Provider value={{ ...contextValue, getToken }}>{props.children}</StateContext.Provider>;\n}\n\nexport function useAppState() {\n  const context = useContext(StateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppStateProvider');\n  }\n  return context;\n}\n"]},"metadata":{},"sourceType":"module"}